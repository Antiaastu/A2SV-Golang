package usecases

import (
	"Task7/domain"
	"Task7/dto"
	"context"
	"errors"
	"time"
)

// TaskRepository defines the behavior expected from any Task data provider.
type TaskRepository interface {
	Create(ctx context.Context, task domain.Task) (domain.Task, error)
	GetAll(ctx context.Context, ownerID string) ([]domain.Task, error)
	GetByID(ctx context.Context, taskID string) (domain.Task, error)
	Update(ctx context.Context, task domain.Task) (domain.Task, error)
	Delete(ctx context.Context, taskID string) error
}

// TaskUsecase encapsulates the business logic related to tasks.
type TaskUsecase struct {
	repo TaskRepository
}

func NewTaskUsecase(r TaskRepository) *TaskUsecase {
	return &TaskUsecase{repo: r}
}

func (u *TaskUsecase) Create(ctx context.Context, in dto.CreateTaskRequest, ownerID string) (domain.Task, error) {
	dueDate, err := time.Parse(time.RFC3339, in.DueDate)
	if err != nil {
		return domain.Task{}, errors.New("invalid due date format, must be RFC3339")
	}
	task := domain.Task{
		ID:          "", // ID should be generated by the database
		Title:       in.Title,
		Description: in.Description,
		Status:      in.Status,
		DueDate:     dueDate,
		OwnerID:     ownerID, // Associate the task with the owner
	}
	if task.OwnerID == "" {
		return domain.Task{}, errors.New("owner ID is required")
	}
	return u.repo.Create(ctx, task)
}
//
func (u *TaskUsecase) GetAll(ctx context.Context, ownerID string) ([]domain.Task, error) {
	return u.repo.GetAll(ctx, ownerID)
}

func (u *TaskUsecase) GetByID(ctx context.Context, taskID string, ownerID string) (domain.Task, error) {
	task, err := u.repo.GetByID(ctx, taskID)
	if err != nil || task.OwnerID != ownerID {
		return domain.Task{}, errors.New("task not found or unauthorized access")	
	}
	return task, nil
}

func (u *TaskUsecase) Update(ctx context.Context , in dto.CreateTaskRequest, taskID string, ownerID string) (domain.Task, error) {
	task, err := u.repo.GetByID(ctx, taskID)
	if err != nil || task.OwnerID != ownerID {
		return domain.Task{}, errors.New("task not found or unauthorized access")
	}
	dueDate, err := time.Parse(time.RFC3339, in.DueDate)
	if err != nil {
		return domain.Task{}, errors.New("invalid due date format, must be RFC3339")
	}
	task.Title = in.Title
	task.Description = in.Description
	task.Status = in.Status
	task.DueDate = dueDate
	return u.repo.Update(ctx, task)
}

func (u *TaskUsecase) Delete(ctx context.Context, taskID string, ownerID string) error {
	task, err := u.repo.GetByID(ctx, taskID)
	if err != nil || task.OwnerID != ownerID {
		return errors.New("task not found or unauthorized access")	
	}
	return u.repo.Delete(ctx, taskID)
}
